# 「失敗」をデバッグする力

## 概要

ソフトウェア開発における「失敗」とは、単に問題が発生したという事実ではなく、原因を特定して修正するための重要な情報源です。本章では、失敗（バグ）を学びの機会として扱うためのマインドセットと、具体的なデバッグ手法を教科書的に整理します。

## 設計との関連：入力・加工・出力／抽象化／設計誤りの考慮

デバッグ時には、実装の不具合だけでなく設計上の観点を振り返ることが重要です。以下の観点をチェック項目として用いると、原因の切り分けが容易になります。

- 入力（Input）：入力仕様に抜けや想定外の値がないか検証します（NULL、空配列、範囲外、フォーマット違いなど）。
- 加工（Process）：データ変換や演算のロジック誤り、副作用や状態の取り扱い、非同期処理の競合などを確認します。
- 出力（Output）：期待される出力の形式・型・境界条件が明確かどうかを確認し、サンプルで検証します。
- 抽象化の妥当性：過度な抽象化や不十分な抽象化が原因で誤りが発生していないか評価します（DRY、単一責任など）。
- 設計誤りの可能性：仕様の曖昧さ、エッジケースの未定義、依存関係の見落としなど、設計段階の欠落が根本原因である場合があります。

これらの観点は、仮説立案と検証を行う際の導線にもなります。実装変更を行う前に設計上のチェックを一度挟むことで、無駄な試行を減らせます。

## デバッグのマインドセット

- バグは攻撃ではなくヒントである：失敗は「何が期待と異なるか」を示している。攻撃的に捉えず、発生している事実から有用な手がかりを抽出します。
- 仮説検証を行う：感覚的な修正を禁止し、仮説を立ててから変更を加えます。仮説は再現条件と期待される変化を含めて明確にします。
- 小さく、素早く検証する：1回の変更は小さく保ち、直後に結果を検証します。変更の粒度が大きいと原因特定が困難になります。

## 仮説検証の手順

1. 再現手順の特定
   - 問題がいつ、どのように発生するかを明確に記述します。
2. 観察とログ採集
   - エラーメッセージ、スタックトレース、関連する変数の状態、入出力を収集します。
3. 仮説の立案
   - 収集した情報に基づき、問題の原因である可能性のある箇所を1つまたは複数仮定します。各仮説には「もしこの仮説が正しければ、こう変わるはずだ」という期待を付与します。
4. 最小限の変更で検証
   - 仮説に基づいて最小限のコード変更または追加のログを行い、期待する変化を検証します。
5. 結果の評価と次の仮説
   - 期待どおりになったか評価し、ならなかった場合は新たな仮説を立てて繰り返します。

## ラバーダック・デバッグ（説明による自己検証）

ラバーダック・デバッグとは、自分のコードの動作を他者（あるいはぬいぐるみ）に説明する過程で理解を深める手法です。説明できない箇所は理解が不十分であり、そこが調査の重点になります。

- 実施手順
  1. 問題のある関数や処理を一行ずつ声に出して説明します。
  2. 説明の中でつじつまが合わない箇所や不明瞭な点を記録します。
  3. その箇所に関して追加の観察（変数の値出力、境界値の確認）を行います。

## 実践上のルール（現場での指針）

- 「なんとなく直す」を禁止する：修正を加える前に仮説と期待結果を必ず書き出します。
- 変更は1行単位で行うことを推奨する（あるいは最小の論理単位で）。
- 変更履歴を残す：GitなどのVCSで小さなコミットを作成し、容易に差分確認とロールバックができる状態にします。
- ログと再現手順を整備する：問題が再現できないと修正の妥当性確認が困難になります。

## よくある原因と短い対処法

- 入力データの想定違い：入力サンプルを増やして検証する。
- 境界値の未処理：境界条件（0件、最大値、NULLなど）を確認する。
- 型や単位のミス：型変換や単位の扱いを明示的にして検証する。
- 非同期処理の競合：ログを増やして発生順序を追跡する。

## 学習用課題

### 課題1：仮説検証を実践する

次の擬似コードでエラーが発生したとする。仮説を立て、最小の変更で検証する手順を書け。

```csharp
int[] numbers = null;
int sum = 0;
for (int i = 0; i < numbers.Length; i++) {
    sum += numbers[i];
}
Console.WriteLine(sum);
```

- 期待する出力例を1つ示す
- 問題の再現手順を記述する
- 仮説を1つ立て、その仮説に対する期待される変化を記述する
- 最小の変更案を1つ示す（1行程度）

### 課題2：ラバーダック・デバッグの実践記録

自分が最近書いた短いコード（10〜30行程度）を1つ選び、ラバーダック方式で説明した内容を記録せよ。

- 説明の要約（各行で何をしているかを一文ずつ）
- 説明できなかった箇所とその理由
- その箇所に対して行った追加調査と結果

### 課題3：現場ルールの適用

チームで以下のルールを導入したと仮定する。導入後に起こりうる利点と注意点をそれぞれ2つ挙げよ。

- 変更は必ず小さなコミットで行う
- 修正前に仮説と期待結果を明文化する

---

## 参考：模範解答（課題1）

- 期待する出力例：プログラムは配列がNULLの場合には例外を発生させず、合計を0として出力することを期待する。
- 再現手順：上記コードを実行すると、`numbers`が`null`のため`numbers.Length`呼び出しで`NullReferenceException`が発生する。
- 仮説：`numbers`がNULLであることが原因でループの条件参照が失敗している。もしこの仮説が正しければ、`numbers`のNULLチェックを追加すると例外が発生しなくなるはずである。
- 最小の変更案（1行）：

```csharp
if (numbers == null) numbers = new int[0];
```

この変更後にプログラムを実行すると、配列長が0となりループは実行されず、合計は0と表示される。
